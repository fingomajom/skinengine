; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	d:\lidengwang\kis\trunk\src\sandbox\Detours Express 2.1\samples\disas\disas.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?s_pHead@BasicBlockLink@@1PAU1@A		; BasicBlockLink::s_pHead
PUBLIC	?s_ppTail@BasicBlockLink@@1PAPAU1@A		; BasicBlockLink::s_ppTail
_BSS	SEGMENT
?s_pHead@BasicBlockLink@@1PAU1@A DD 01H DUP (?)		; BasicBlockLink::s_pHead
_s_pbBegin DD	01H DUP (?)
_s_pbLimit DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
?s_ppTail@BasicBlockLink@@1PAPAU1@A DD FLAT:?s_pHead@BasicBlockLink@@1PAU1@A ; BasicBlockLink::s_ppTail
_DATA	ENDS
PUBLIC	??0BasicBlockLink@@QAE@PAEPAD@Z			; BasicBlockLink::BasicBlockLink
; Function compile flags: /Ogspy
; File d:\lidengwang\kis\trunk\src\sandbox\detours express 2.1\samples\disas\disas.cpp
;	COMDAT ??0BasicBlockLink@@QAE@PAEPAD@Z
_TEXT	SEGMENT
_pbEntry$ = 8						; size = 4
_pszName$ = 12						; size = 4
??0BasicBlockLink@@QAE@PAEPAD@Z PROC			; BasicBlockLink::BasicBlockLink, COMDAT
; _this$ = ecx

; 30   :     BasicBlockLink(PBYTE pbEntry, PCHAR pszName = NULL)

  00000	8b c1		 mov	 eax, ecx

; 31   :     {
; 32   :         m_pNext = NULL;
; 33   :         m_pbEntry = pbEntry;

  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR _pbEntry$[esp-4]
  00006	83 20 00	 and	 DWORD PTR [eax], 0
  00009	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 34   :         m_pszName = pszName;

  0000c	8b 4c 24 08	 mov	 ecx, DWORD PTR _pszName$[esp-4]
  00010	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 35   : 
; 36   :         *s_ppTail = this;

  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?s_ppTail@BasicBlockLink@@1PAPAU1@A ; BasicBlockLink::s_ppTail
  00019	89 01		 mov	 DWORD PTR [ecx], eax

; 37   :         s_ppTail = &m_pNext;

  0001b	a3 00 00 00 00	 mov	 DWORD PTR ?s_ppTail@BasicBlockLink@@1PAPAU1@A, eax ; BasicBlockLink::s_ppTail

; 38   :     }

  00020	c2 08 00	 ret	 8
??0BasicBlockLink@@QAE@PAEPAD@Z ENDP			; BasicBlockLink::BasicBlockLink
_TEXT	ENDS
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5?$AA@			; `string'
PUBLIC	??_C@_04NOJCDH@?$CF02x?$AA@			; `string'
PUBLIC	?DumpMemoryFragment@@YAXPAEKK@Z			; DumpMemoryFragment
EXTRN	__imp__printf:PROC
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5?$AA@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NOJCDH@?$CF02x?$AA@
CONST	SEGMENT
??_C@_04NOJCDH@?$CF02x?$AA@ DB '%02x', 00H		; `string'
; Function compile flags: /Ogspy
CONST	ENDS
;	COMDAT ?DumpMemoryFragment@@YAXPAEKK@Z
_TEXT	SEGMENT
_pbData$ = 8						; size = 4
_cbData$ = 12						; size = 4
_cbSpace$ = 16						; size = 4
?DumpMemoryFragment@@YAXPAEKK@Z PROC			; DumpMemoryFragment, COMDAT

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 63   :     ULONG n = 0;

  00004	33 f6		 xor	 esi, esi

; 64   :     for (; n < cbSpace; n++) {

  00006	39 75 10	 cmp	 DWORD PTR _cbSpace$[ebp], esi
  00009	57		 push	 edi
  0000a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__printf
  00010	76 25		 jbe	 SHORT $LN5@DumpMemory
$LL7@DumpMemory:

; 65   :         if (n < cbData) {

  00012	3b 75 0c	 cmp	 esi, DWORD PTR _cbData$[ebp]
  00015	73 12		 jae	 SHORT $LN4@DumpMemory

; 66   :             printf("%02x", pbData[n]);

  00017	8b 45 08	 mov	 eax, DWORD PTR _pbData$[ebp]
  0001a	0f b6 04 06	 movzx	 eax, BYTE PTR [esi+eax]
  0001e	50		 push	 eax
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_04NOJCDH@?$CF02x?$AA@
  00024	ff d7		 call	 edi
  00026	59		 pop	 ecx

; 67   :         }
; 68   :         else {

  00027	eb 07		 jmp	 SHORT $LN12@DumpMemory
$LN4@DumpMemory:

; 69   :             printf("  ");

  00029	68 00 00 00 00	 push	 OFFSET ??_C@_02KNHHEEKP@?5?5?$AA@
  0002e	ff d7		 call	 edi
$LN12@DumpMemory:
  00030	46		 inc	 esi
  00031	3b 75 10	 cmp	 esi, DWORD PTR _cbSpace$[ebp]
  00034	59		 pop	 ecx
  00035	72 db		 jb	 SHORT $LL7@DumpMemory
$LN5@DumpMemory:

; 70   :         }
; 71   :     }
; 72   :     if (n < cbData) {

  00037	3b 75 0c	 cmp	 esi, DWORD PTR _cbData$[ebp]
  0003a	73 07		 jae	 SHORT $LN2@DumpMemory

; 73   :         printf(".");

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_01LFCBOECM@?4?$AA@

; 74   :     }
; 75   :     else {

  00041	eb 05		 jmp	 SHORT $LN13@DumpMemory
$LN2@DumpMemory:

; 76   :         printf(" ");

  00043	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
$LN13@DumpMemory:
  00048	ff d7		 call	 edi
  0004a	59		 pop	 ecx
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi

; 77   :     }
; 78   : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?DumpMemoryFragment@@YAXPAEKK@Z ENDP			; DumpMemoryFragment
_TEXT	ENDS
PUBLIC	?IsTerminate@@YAHPAE@Z				; IsTerminate
; Function compile flags: /Ogspy
;	COMDAT ?IsTerminate@@YAHPAE@Z
_TEXT	SEGMENT
_pbSrc$ = 8						; size = 4
?IsTerminate@@YAHPAE@Z PROC				; IsTerminate, COMDAT

; 82   :     if (0xC3 == pbSrc[0] ||                             // RET
; 83   :         0xCB == pbSrc[0] ||                             // RETF
; 84   :         0xC2 == pbSrc[0] ||                             // RET dw
; 85   :         0xCA == pbSrc[0] ||                             // RETF dw
; 86   :         0xEB == pbSrc[0] ||                             // JMP ob
; 87   :         0xE9 == pbSrc[0] ||                             // JMP ol
; 88   :         0xEA == pbSrc[0]) {                             // JMP ol

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _pbSrc$[esp-4]
  00004	8a 01		 mov	 al, BYTE PTR [ecx]
  00006	3c c3		 cmp	 al, 195			; 000000c3H
  00008	74 25		 je	 SHORT $LN2@IsTerminat
  0000a	3c cb		 cmp	 al, 203			; 000000cbH
  0000c	74 21		 je	 SHORT $LN2@IsTerminat
  0000e	3c c2		 cmp	 al, 194			; 000000c2H
  00010	74 1d		 je	 SHORT $LN2@IsTerminat
  00012	3c ca		 cmp	 al, 202			; 000000caH
  00014	74 19		 je	 SHORT $LN2@IsTerminat
  00016	3c eb		 cmp	 al, 235			; 000000ebH
  00018	74 15		 je	 SHORT $LN2@IsTerminat
  0001a	3c e9		 cmp	 al, 233			; 000000e9H
  0001c	74 11		 je	 SHORT $LN2@IsTerminat
  0001e	3c ea		 cmp	 al, 234			; 000000eaH
  00020	74 0d		 je	 SHORT $LN2@IsTerminat

; 91   :     }
; 92   :     if (0xff == pbSrc[0] && 0x25 == pbSrc[1])           // JMP [addr]

  00022	3c ff		 cmp	 al, 255			; 000000ffH
  00024	75 06		 jne	 SHORT $LN1@IsTerminat
  00026	80 79 01 25	 cmp	 BYTE PTR [ecx+1], 37	; 00000025H

; 93   :         return TRUE;

  0002a	74 03		 je	 SHORT $LN2@IsTerminat
$LN1@IsTerminat:

; 94   :     return FALSE;

  0002c	33 c0		 xor	 eax, eax

; 95   : }

  0002e	c3		 ret	 0
$LN2@IsTerminat:

; 89   : 
; 90   :         return TRUE;

  0002f	33 c0		 xor	 eax, eax
  00031	40		 inc	 eax

; 95   : }

  00032	c3		 ret	 0
?IsTerminate@@YAHPAE@Z ENDP				; IsTerminate
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_06CEAPKPKI@?5?$CFp?$CFc?6?$AA@		; `string'
PUBLIC	??_C@_0L@OCALGHGF@?5?5Dynamic?6?$AA@		; `string'
PUBLIC	??_C@_07IMMPLIEL@?5?5?5?5?$CFp?3?$AA@		; `string'
PUBLIC	??_C@_04JKGFCPCI@?$CFs?3?6?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?TestDetourCopyInstruction@@YAHPAEPAD@Z		; TestDetourCopyInstruction
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	_DetourCopyInstructionEx@16:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06CEAPKPKI@?5?$CFp?$CFc?6?$AA@
CONST	SEGMENT
??_C@_06CEAPKPKI@?5?$CFp?$CFc?6?$AA@ DB ' %p%c', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OCALGHGF@?5?5Dynamic?6?$AA@
CONST	SEGMENT
??_C@_0L@OCALGHGF@?5?5Dynamic?6?$AA@ DB '  Dynamic', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IMMPLIEL@?5?5?5?5?$CFp?3?$AA@
CONST	SEGMENT
??_C@_07IMMPLIEL@?5?5?5?5?$CFp?3?$AA@ DB '    %p:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04JKGFCPCI@?$CFs?3?6?$AA@
CONST	SEGMENT
??_C@_04JKGFCPCI@?$CFs?3?6?$AA@ DB '%s:', 0aH, 00H	; `string'
; Function compile flags: /Ogspy
CONST	ENDS
;	COMDAT ?TestDetourCopyInstruction@@YAHPAEPAD@Z
_TEXT	SEGMENT
_lExtra$62235 = -32					; size = 4
_pbTarget$62236 = -28					; size = 4
_nIns$ = -24						; size = 4
_rbDst$62234 = -20					; size = 128
__$ArrayPad$ = 108					; size = 4
_pbSrcInstruction$ = 120				; size = 4
_pszFunction$ = 124					; size = 4
?TestDetourCopyInstruction@@YAHPAEPAD@Z PROC		; TestDetourCopyInstruction, COMDAT

; 98   : {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 6c	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	8b 45 7c	 mov	 eax, DWORD PTR _pszFunction$[ebp]
  00018	8b 4d 78	 mov	 ecx, DWORD PTR _pbSrcInstruction$[ebp]

; 99   :     PBYTE pbSrc = pbSrcInstruction;
; 100  :     ULONG nIns = 0;

  0001b	83 65 e8 00	 and	 DWORD PTR _nIns$[ebp], 0

; 101  : 
; 102  :     if (pszFunction) {

  0001f	85 c0		 test	 eax, eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__printf
  00029	57		 push	 edi
  0002a	8b d9		 mov	 ebx, ecx
  0002c	74 0a		 je	 SHORT $LL25@TestDetour

; 103  :         printf("%s:\n", pszFunction);

  0002e	50		 push	 eax
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_04JKGFCPCI@?$CFs?3?6?$AA@
  00034	ff d6		 call	 esi
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx
$LL25@TestDetour:

; 104  :     }
; 105  :     for (; nIns < 4096; nIns++) {
; 106  :         BYTE rbDst[128];
; 107  :         LONG lExtra = 0;

  00038	83 65 e0 00	 and	 DWORD PTR _lExtra$62235[ebp], 0

; 108  :         PVOID pbTarget = NULL;

  0003c	83 65 e4 00	 and	 DWORD PTR _pbTarget$62236[ebp], 0

; 109  :         ULONG cbStep = (ULONG)((PBYTE)DetourCopyInstructionEx(rbDst, pbSrc,
; 110  :                                                               &pbTarget, &lExtra) - pbSrc);

  00040	8d 45 e0	 lea	 eax, DWORD PTR _lExtra$62235[ebp]
  00043	50		 push	 eax
  00044	8d 45 e4	 lea	 eax, DWORD PTR _pbTarget$62236[ebp]
  00047	50		 push	 eax
  00048	53		 push	 ebx
  00049	8d 45 ec	 lea	 eax, DWORD PTR _rbDst$62234[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _DetourCopyInstructionEx@16
  00052	8b f8		 mov	 edi, eax

; 111  : 
; 112  :         printf("    %p:", pbSrc);

  00054	53		 push	 ebx
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_07IMMPLIEL@?5?5?5?5?$CFp?3?$AA@
  0005a	2b fb		 sub	 edi, ebx
  0005c	ff d6		 call	 esi

; 113  :         DumpMemoryFragment(rbDst, cbStep, 10);

  0005e	6a 0a		 push	 10			; 0000000aH
  00060	8d 45 ec	 lea	 eax, DWORD PTR _rbDst$62234[ebp]
  00063	57		 push	 edi
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ?DumpMemoryFragment@@YAXPAEKK@Z ; DumpMemoryFragment

; 114  :         printf(" ");

  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  0006f	ff d6		 call	 esi

; 115  :         DumpMemoryFragment(rbDst, cbStep, 10);

  00071	6a 0a		 push	 10			; 0000000aH
  00073	8d 45 ec	 lea	 eax, DWORD PTR _rbDst$62234[ebp]
  00076	57		 push	 edi
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?DumpMemoryFragment@@YAXPAEKK@Z ; DumpMemoryFragment

; 116  :         if (pbTarget) {

  0007d	8b 45 e4	 mov	 eax, DWORD PTR _pbTarget$62236[ebp]
  00080	83 c4 24	 add	 esp, 36			; 00000024H
  00083	85 c0		 test	 eax, eax
  00085	74 31		 je	 SHORT $LN7@TestDetour

; 117  :             if (pbTarget == DETOUR_INSTRUCTION_TARGET_DYNAMIC) {

  00087	83 f8 ff	 cmp	 eax, -1
  0008a	75 07		 jne	 SHORT $LN6@TestDetour

; 118  :                 printf("  Dynamic\n");

  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_0L@OCALGHGF@?5?5Dynamic?6?$AA@

; 119  :             }
; 120  :             else {

  00091	eb 2a		 jmp	 SHORT $LN28@TestDetour
$LN6@TestDetour:

; 121  :                 printf(" %p%c\n", pbTarget,
; 122  :                        (pbTarget >= s_pbBegin && pbTarget < s_pbLimit) ? ' ' : '!');

  00093	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _s_pbBegin
  00099	72 0a		 jb	 SHORT $LN14@TestDetour
  0009b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _s_pbLimit
  000a1	b1 20		 mov	 cl, 32			; 00000020H
  000a3	72 02		 jb	 SHORT $LN15@TestDetour
$LN14@TestDetour:
  000a5	b1 21		 mov	 cl, 33			; 00000021H
$LN15@TestDetour:
  000a7	0f be c9	 movsx	 ecx, cl
  000aa	51		 push	 ecx
  000ab	50		 push	 eax
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_06CEAPKPKI@?5?$CFp?$CFc?6?$AA@
  000b1	ff d6		 call	 esi
  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 123  :             }
; 124  :         }
; 125  :         else {

  000b6	eb 08		 jmp	 SHORT $LN4@TestDetour
$LN7@TestDetour:

; 126  :             printf("\n");

  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
$LN28@TestDetour:
  000bd	ff d6		 call	 esi
  000bf	59		 pop	 ecx
$LN4@TestDetour:

; 127  :         }
; 128  : 
; 129  :         if (pbTarget && pbTarget != DETOUR_INSTRUCTION_TARGET_DYNAMIC) {

  000c0	8b 45 e4	 mov	 eax, DWORD PTR _pbTarget$62236[ebp]
  000c3	85 c0		 test	 eax, eax
  000c5	74 3f		 je	 SHORT $LN16@TestDetour
  000c7	83 f8 ff	 cmp	 eax, -1
  000ca	74 3a		 je	 SHORT $LN16@TestDetour

; 130  :             if (pbTarget > pbSrc &&
; 131  :                 pbTarget >= s_pbBegin &&
; 132  :                 pbTarget < s_pbLimit
; 133  :                ) {

  000cc	3b c3		 cmp	 eax, ebx
  000ce	76 36		 jbe	 SHORT $LN16@TestDetour
  000d0	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _s_pbBegin
  000d6	72 2e		 jb	 SHORT $LN16@TestDetour
  000d8	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _s_pbLimit
  000de	73 26		 jae	 SHORT $LN16@TestDetour

; 134  :                 (void) new BasicBlockLink((PBYTE)pbTarget, NULL);

  000e0	6a 0c		 push	 12			; 0000000cH
  000e2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000e7	85 c0		 test	 eax, eax
  000e9	59		 pop	 ecx
  000ea	74 1a		 je	 SHORT $LN16@TestDetour
  000ec	8b 4d e4	 mov	 ecx, DWORD PTR _pbTarget$62236[ebp]
  000ef	83 20 00	 and	 DWORD PTR [eax], 0
  000f2	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  000f6	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?s_ppTail@BasicBlockLink@@1PAPAU1@A ; BasicBlockLink::s_ppTail
  000ff	89 01		 mov	 DWORD PTR [ecx], eax
  00101	a3 00 00 00 00	 mov	 DWORD PTR ?s_ppTail@BasicBlockLink@@1PAPAU1@A, eax ; BasicBlockLink::s_ppTail
$LN16@TestDetour:

; 135  :             }
; 136  :         }
; 137  : 
; 138  :         if (IsTerminate(pbSrc)) {

  00106	53		 push	 ebx
  00107	e8 00 00 00 00	 call	 ?IsTerminate@@YAHPAE@Z	; IsTerminate
  0010c	85 c0		 test	 eax, eax
  0010e	59		 pop	 ecx
  0010f	75 12		 jne	 SHORT $LN21@TestDetour

; 139  :             break;
; 140  :         }
; 141  : 
; 142  :         pbSrc += cbStep;

  00111	03 df		 add	 ebx, edi
  00113	ff 45 e8	 inc	 DWORD PTR _nIns$[ebp]
  00116	81 7d e8 00 10
	00 00		 cmp	 DWORD PTR _nIns$[ebp], 4096 ; 00001000H
  0011d	0f 82 15 ff ff
	ff		 jb	 $LL25@TestDetour
$LN21@TestDetour:

; 143  :     }
; 144  :     return nIns;
; 145  : }

  00123	8b 4d 6c	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00126	8b 45 e8	 mov	 eax, DWORD PTR _nIns$[ebp]
  00129	5f		 pop	 edi
  0012a	5e		 pop	 esi
  0012b	33 cd		 xor	 ecx, ebp
  0012d	5b		 pop	 ebx
  0012e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00133	83 c5 70	 add	 ebp, 112		; 00000070H
  00136	c9		 leave
  00137	c3		 ret	 0
?TestDetourCopyInstruction@@YAHPAEPAD@Z ENDP		; TestDetourCopyInstruction
_TEXT	ENDS
PUBLIC	??_C@_09DECKCNEJ@?$FLNO?5NAME?$FN?$AA@		; `string'
PUBLIC	?ExportCallback@@YGHPAXKPADPAE@Z		; ExportCallback
;	COMDAT ??_C@_09DECKCNEJ@?$FLNO?5NAME?$FN?$AA@
CONST	SEGMENT
??_C@_09DECKCNEJ@?$FLNO?5NAME?$FN?$AA@ DB '[NO NAME]', 00H ; `string'
; Function compile flags: /Ogspy
CONST	ENDS
;	COMDAT ?ExportCallback@@YGHPAXKPADPAE@Z
_TEXT	SEGMENT
_pContext$ = 8						; size = 4
_nOrdinal$ = 12						; size = 4
_pszSymbol$ = 16					; size = 4
_pbTarget$ = 20						; size = 4
?ExportCallback@@YGHPAXKPADPAE@Z PROC			; ExportCallback, COMDAT

; 152  :     (void)pContext;
; 153  :     (void)nOrdinal;
; 154  :     (void)pbTarget;
; 155  : 
; 156  :     (VOID) new BasicBlockLink(pbTarget, pszSymbol ? pszSymbol : "[NO NAME]");

  00000	6a 0c		 push	 12			; 0000000cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	85 c0		 test	 eax, eax
  00009	59		 pop	 ecx
  0000a	74 19		 je	 SHORT $LN5@ExportCall
  0000c	8b 54 24 0c	 mov	 edx, DWORD PTR _pszSymbol$[esp-4]
  00010	85 d2		 test	 edx, edx
  00012	75 05		 jne	 SHORT $LN4@ExportCall
  00014	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_09DECKCNEJ@?$FLNO?5NAME?$FN?$AA@
$LN4@ExportCall:
  00019	52		 push	 edx
  0001a	ff 74 24 14	 push	 DWORD PTR _pbTarget$[esp]
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 ??0BasicBlockLink@@QAE@PAEPAD@Z ; BasicBlockLink::BasicBlockLink
$LN5@ExportCall:

; 157  :     return TRUE;

  00025	33 c0		 xor	 eax, eax
  00027	40		 inc	 eax

; 158  : }

  00028	c2 10 00	 ret	 16			; 00000010H
?ExportCallback@@YGHPAXKPADPAE@Z ENDP			; ExportCallback
_TEXT	ENDS
PUBLIC	??_C@_08GNCACJHJ@failed?$CB?6?$AA@		; `string'
PUBLIC	??_C@_0BB@JAOLMHA@failed?5on?5last?4?6?$AA@	; `string'
PUBLIC	??_C@_07HEIMHJMO@?$FL?$CF16p?$FN?5?$AA@		; `string'
PUBLIC	??_C@_06GJHPCIGB@?$CF08x?5?5?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_WinMain@16
EXTRN	_TestCodes:BYTE
;	COMDAT ??_C@_08GNCACJHJ@failed?$CB?6?$AA@
CONST	SEGMENT
??_C@_08GNCACJHJ@failed?$CB?6?$AA@ DB 'failed!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JAOLMHA@failed?5on?5last?4?6?$AA@
CONST	SEGMENT
??_C@_0BB@JAOLMHA@failed?5on?5last?4?6?$AA@ DB 'failed on last.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HEIMHJMO@?$FL?$CF16p?$FN?5?$AA@
CONST	SEGMENT
??_C@_07HEIMHJMO@?$FL?$CF16p?$FN?5?$AA@ DB '[%16p] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GJHPCIGB@?$CF08x?5?5?$AA@
CONST	SEGMENT
??_C@_06GJHPCIGB@?$CF08x?5?5?$AA@ DB '%08x  ', 00H	; `string'
; Function compile flags: /Ogspy
CONST	ENDS
;	COMDAT _WinMain@16
_TEXT	SEGMENT
_pbTarget$62294 = -140					; size = 4
_lExtra$62293 = -136					; size = 4
_rbDst$62292 = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
_hinst$ = 8						; size = 4
_hprev$ = 12						; size = 4
_lpszCmdLine$ = 16					; size = 4
_nCmdShow$ = 20						; size = 4
_WinMain@16 PROC					; COMDAT

; 317  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 318  :     (void)hprev;
; 319  :     (void)hinst;
; 320  :     (void)lpszCmdLine;
; 321  :     (void)nCmdShow;
; 322  : 
; 323  : #ifdef DETOURS_IA64
; 324  : #error Feature not supported in this release.
; 325  : 
; 326  : 
; 327  : 
; 328  : 
; 329  : 
; 330  : 
; 331  : 
; 332  : 
; 333  : 
; 334  : 
; 335  : 
; 336  : 
; 337  : 
; 338  : 
; 339  : 
; 340  : 
; 341  : 
; 342  : 
; 343  : 
; 344  : 
; 345  : 
; 346  : 
; 347  : 
; 348  : 
; 349  : 
; 350  : 
; 351  : 
; 352  : 
; 353  : 
; 354  : 
; 355  : 
; 356  : 
; 357  : 
; 358  : 
; 359  : 
; 360  : 
; 361  : 
; 362  : 
; 363  : 
; 364  : 
; 365  : 
; 366  : 
; 367  : 
; 368  : 
; 369  : 
; 370  : 
; 371  : 
; 372  : 
; 373  : 
; 374  : 
; 375  : 
; 376  : 
; 377  : 
; 378  : 
; 379  : 
; 380  : 
; 381  : 
; 382  : 
; 383  : 
; 384  : 
; 385  : 
; 386  : 
; 387  : 
; 388  : 
; 389  : 
; 390  : 
; 391  : 
; 392  : 
; 393  : 
; 394  : 
; 395  : 
; 396  : 
; 397  : 
; 398  : 
; 399  : 
; 400  : 
; 401  : 
; 402  : 
; 403  : 
; 404  : 
; 405  : 
; 406  : 
; 407  : 
; 408  : 
; 409  : 
; 410  : 
; 411  : 
; 412  : 
; 413  : 
; 414  : 
; 415  : 
; 416  : 
; 417  : 
; 418  : 
; 419  : 
; 420  : #endif // DETOURS_IA64
; 421  : 
; 422  : #if defined(DETOURS_X64) || defined(DETOURS_X86)
; 423  :     // First we check the pre-canned TestCodes from disasm.asm
; 424  :     //
; 425  :     for (PBYTE pbTest = TestCodes;;) {
; 426  :         if (pbTest[0] != 0xcc) {    // int 3

  00013	80 3d 00 00 00
	00 cc		 cmp	 BYTE PTR _TestCodes, 204 ; 000000ccH
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__printf
  00022	57		 push	 edi
  00023	bb 00 00 00 00	 mov	 ebx, OFFSET _TestCodes
  00028	0f 85 93 00 00
	00		 jne	 $LN10@WinMain
$LL5@WinMain:

; 432  :         }
; 433  : 
; 434  :         BYTE rbDst[128];
; 435  :         LONG lExtra = 0;

  0002e	83 a5 78 ff ff
	ff 00		 and	 DWORD PTR _lExtra$62293[ebp], 0

; 436  :         PVOID pbTarget = NULL;

  00035	83 a5 74 ff ff
	ff 00		 and	 DWORD PTR _pbTarget$62294[ebp], 0

; 437  :         PBYTE pbNext = (PBYTE)DetourCopyInstructionEx(rbDst, pbTest + 1, &pbTarget, &lExtra);

  0003c	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _lExtra$62293[ebp]
  00042	51		 push	 ecx
  00043	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _pbTarget$62294[ebp]
  00049	51		 push	 ecx
  0004a	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  0004d	50		 push	 eax
  0004e	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _rbDst$62292[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _DetourCopyInstructionEx@16
  0005a	8b f8		 mov	 edi, eax

; 438  : 
; 439  :         LONG cbTest = (LONG)(pbNext - (pbTest + 1));

  0005c	2b fb		 sub	 edi, ebx

; 440  : 
; 441  :         printf("%08x  ", pbTest + 1 - TestCodes);

  0005e	8b c3		 mov	 eax, ebx
  00060	2d 00 00 00 00	 sub	 eax, OFFSET _TestCodes
  00065	4f		 dec	 edi
  00066	40		 inc	 eax
  00067	50		 push	 eax
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_06GJHPCIGB@?$CF08x?5?5?$AA@
  0006d	ff d6		 call	 esi

; 442  :         DumpMemoryFragment(pbTest + 1, cbTest, 12);

  0006f	6a 0c		 push	 12			; 0000000cH
  00071	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00074	57		 push	 edi
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ?DumpMemoryFragment@@YAXPAEKK@Z ; DumpMemoryFragment

; 443  :         printf("[%16p] ", pbTarget);

  0007b	ff b5 74 ff ff
	ff		 push	 DWORD PTR _pbTarget$62294[ebp]
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_07HEIMHJMO@?$FL?$CF16p?$FN?5?$AA@
  00086	ff d6		 call	 esi

; 444  :         DumpMemoryFragment(rbDst, cbTest + lExtra, 11);

  00088	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _lExtra$62293[ebp]
  0008e	03 c7		 add	 eax, edi
  00090	6a 0b		 push	 11			; 0000000bH
  00092	50		 push	 eax
  00093	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _rbDst$62292[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ?DumpMemoryFragment@@YAXPAEKK@Z ; DumpMemoryFragment

; 445  :         printf("\n");

  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  000a4	ff d6		 call	 esi

; 446  : 
; 447  :         if (pbTest[cbTest + 1] != 0xcc) {

  000a6	8d 5c 1f 01	 lea	 ebx, DWORD PTR [edi+ebx+1]
  000aa	83 c4 2c	 add	 esp, 44			; 0000002cH
  000ad	80 3b cc	 cmp	 BYTE PTR [ebx], 204	; 000000ccH
  000b0	75 3e		 jne	 SHORT $LN11@WinMain

; 450  :         }
; 451  : 
; 452  :         pbTest += 1 + cbTest;
; 453  : 
; 454  :         if (pbTest[0] == 0xcc && pbTest[1] == 0xcc) {

  000b2	80 7b 01 cc	 cmp	 BYTE PTR [ebx+1], 204	; 000000ccH
  000b6	74 42		 je	 SHORT $LN12@WinMain

; 318  :     (void)hprev;
; 319  :     (void)hinst;
; 320  :     (void)lpszCmdLine;
; 321  :     (void)nCmdShow;
; 322  : 
; 323  : #ifdef DETOURS_IA64
; 324  : #error Feature not supported in this release.
; 325  : 
; 326  : 
; 327  : 
; 328  : 
; 329  : 
; 330  : 
; 331  : 
; 332  : 
; 333  : 
; 334  : 
; 335  : 
; 336  : 
; 337  : 
; 338  : 
; 339  : 
; 340  : 
; 341  : 
; 342  : 
; 343  : 
; 344  : 
; 345  : 
; 346  : 
; 347  : 
; 348  : 
; 349  : 
; 350  : 
; 351  : 
; 352  : 
; 353  : 
; 354  : 
; 355  : 
; 356  : 
; 357  : 
; 358  : 
; 359  : 
; 360  : 
; 361  : 
; 362  : 
; 363  : 
; 364  : 
; 365  : 
; 366  : 
; 367  : 
; 368  : 
; 369  : 
; 370  : 
; 371  : 
; 372  : 
; 373  : 
; 374  : 
; 375  : 
; 376  : 
; 377  : 
; 378  : 
; 379  : 
; 380  : 
; 381  : 
; 382  : 
; 383  : 
; 384  : 
; 385  : 
; 386  : 
; 387  : 
; 388  : 
; 389  : 
; 390  : 
; 391  : 
; 392  : 
; 393  : 
; 394  : 
; 395  : 
; 396  : 
; 397  : 
; 398  : 
; 399  : 
; 400  : 
; 401  : 
; 402  : 
; 403  : 
; 404  : 
; 405  : 
; 406  : 
; 407  : 
; 408  : 
; 409  : 
; 410  : 
; 411  : 
; 412  : 
; 413  : 
; 414  : 
; 415  : 
; 416  : 
; 417  : 
; 418  : 
; 419  : 
; 420  : #endif // DETOURS_IA64
; 421  : 
; 422  : #if defined(DETOURS_X64) || defined(DETOURS_X86)
; 423  :     // First we check the pre-canned TestCodes from disasm.asm
; 424  :     //
; 425  :     for (PBYTE pbTest = TestCodes;;) {
; 426  :         if (pbTest[0] != 0xcc) {    // int 3

  000b8	80 3b cc	 cmp	 BYTE PTR [ebx], 204	; 000000ccH
  000bb	0f 84 6d ff ff
	ff		 je	 $LL5@WinMain
$LN10@WinMain:

; 427  :             printf("%08x  ", pbTest - TestCodes);

  000c1	8b c3		 mov	 eax, ebx
  000c3	2d 00 00 00 00	 sub	 eax, OFFSET _TestCodes
  000c8	50		 push	 eax
  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_06GJHPCIGB@?$CF08x?5?5?$AA@
  000ce	ff d6		 call	 esi

; 428  :             DumpMemoryFragment(pbTest, 8, 8);

  000d0	6a 08		 push	 8
  000d2	6a 08		 push	 8
  000d4	53		 push	 ebx
  000d5	e8 00 00 00 00	 call	 ?DumpMemoryFragment@@YAXPAEKK@Z ; DumpMemoryFragment

; 429  :             printf("\n");

  000da	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  000df	ff d6		 call	 esi

; 430  :             printf("failed on last.\n");

  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JAOLMHA@failed?5on?5last?4?6?$AA@
  000e6	ff d6		 call	 esi
  000e8	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN13@WinMain:

; 431  :             return 1;

  000eb	33 c0		 xor	 eax, eax
  000ed	40		 inc	 eax
  000ee	eb 0c		 jmp	 SHORT $LN6@WinMain
$LN11@WinMain:

; 448  :             printf("failed!\n");

  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_08GNCACJHJ@failed?$CB?6?$AA@
  000f5	ff d6		 call	 esi
  000f7	59		 pop	 ecx

; 449  :             return 1;

  000f8	eb f1		 jmp	 SHORT $LN13@WinMain
$LN12@WinMain:

; 455  :             break;
; 456  :         }
; 457  :     }
; 458  : 
; 459  : #if 0
; 460  :     // Then we check all of the code we can find in user32.dll
; 461  :     //
; 462  :     HINSTANCE hInst = LoadLibrary("user32.dll");
; 463  :     printf("Loaded: user32.dll: %p\n", hInst);
; 464  : 
; 465  :     s_pbBegin = (PBYTE)hInst;
; 466  :     s_pbLimit = s_pbBegin + DetourGetModuleSize(hInst);
; 467  : 
; 468  :     PBYTE pbEntry = DetourGetEntryPoint(hInst);
; 469  :     (VOID) new BasicBlockLink(pbEntry, "user32.dll");
; 470  : 
; 471  :     DetourEnumerateExports(hInst, NULL, ExportCallback);
; 472  : 
; 473  :     ULONG nIns = 0;
; 474  :     for (BasicBlockLink *pLink = BasicBlockLink::GetHead();
; 475  :          pLink; pLink = pLink->Next()) {
; 476  : 
; 477  :         nIns += TestDetourCopyInstruction(pLink->m_pbEntry, pLink->m_pszName);
; 478  :         if (nIns > 100000) {
; 479  :             break;
; 480  :         }
; 481  :     }
; 482  :     printf("Disassembled %d instructions.\n", nIns);
; 483  : #endif
; 484  : #endif // DETOURS_X86 || DETOURS_X64
; 485  : 
; 486  :     return 0;

  000fa	33 c0		 xor	 eax, eax
$LN6@WinMain:

; 487  : }

  000fc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	33 cd		 xor	 ecx, ebp
  00103	5b		 pop	 ebx
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	c9		 leave
  0010a	c2 10 00	 ret	 16			; 00000010H
_WinMain@16 ENDP
_TEXT	ENDS
END
